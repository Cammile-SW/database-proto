
'''
[module structure hierarchy]

unidentified class which will be discussed in future

    +- binary tree 01
        +- node instance 01
        +- node instance 02
        > node instances goes on ...

    +- binary tree 02
        +- node instance 01
        +- node instance 02
        > node instances goes on ...
    
    > binary tree instances goes on ...

'''
import json

from typing import TypeVar
from typing import IO

# variables for strong-type.

from strong_type import Itself
from strong_type import is_satisfied_strongly

strong_node_init = (
    (1, 'key', [int]), 
    (3, 'node_on_left', [None, Itself]), 
    (4, 'node_on_right', [None, Itself]),
    )

strong_btree_init = (
    (1, 'key', [int]),
    )

# variables for type-hint.

NodeType = TypeVar('NodeType')
BinaryTreeType = TypeVar('BinaryTreeType')

# module description.

class ArgumentException(Exception):
    '''argument exception class'''

    def __init__(self, message:str):
        super().__init__(message)

class Node(object):
    '''node class'''

    # key for identify node instance
    _key = None

    # value which is contained node instance
    _value = None

    # left node instance on this instance (reference) 
    _node_on_left = None

    # right node instance on this instance (reference)
    _node_on_right = None
    
    @is_satisfied_strongly(strong_node_init)
    def __init__(
            self, 
            key:int, 
            value:object=None,
            node_on_left:NodeType=None,
            node_on_right:NodeType=None
            ):

        # key should be given by 
        # relative-upper management class instance,
        # not by itself.
        # e.g. this node key is generated by its tree.

        self._key = key
        self._value = value
        self._node_on_left = node_on_left
        self._node_on_right = node_on_right

    def __str__(self):
        return f'{self.__class__.__name__}<{self.key},{self.value}>'
    
    def __repr__(self):
        return f'{self.__class__.__name__}<{self.key},{self.value}>'

    @property
    def key(self) -> int: #why str?
        return self._key

    @property
    def value(self) -> object:
        return self._value

    @property
    def node_on_left(self) -> NodeType:
        return self._node_on_left

    @property
    def node_on_right(self) -> NodeType:
        return self._node_on_left

class BinaryTree(object):
    '''node class'''
    
    # key for identify binary tree instance
    _key = None

    # root node instance
    _root = None

    # nodes instance
    _nodes = {}

    @is_satisfied_strongly(strong_btree_init)
    def __init__(self, key:int):
        # key should be given by 
        # a relative-upper management class instance,
        # not by itself.

        self._key = key
        self._nodes.update({'key':key})

    @property
    def key(self) -> int:
        return self._key

    @property
    def nodes(self) -> dict:
        return self._nodes

    def _insert_as_value(self, root:NodeType, key:int,  value:object) -> NodeType:
        # do not describe anything directly.
        # your code goes here, not a public method.

        #insert key,value to _nodes
        self._nodes.update({key:value})

        # generate node -> insert
        node = Node(key,value) 

        if root is None:
            #inserting first node
            root = node
        else:
            if root._key == node._key:
            #raise Exception
                pass
            elif root._key > node._key:
                root._node_on_left = self. _insert_as_node(root._node_on_left, node)
            else:
                root._node_on_right = self. _insert_as_node(root._node_on_right, node)

        return root
    
    def _insert_as_node(self, root:NodeType, node:NodeType) -> NodeType:
        # do not describe anything directly.
        # your code goes here, not a public method.

        #insert key,value to _nodes
        self._nodes.update({node.key:node.value})

        if root is None:
            #inserting first node
            root = node
        else:
            if root._key == node._key:
                #raise Exception
                pass
            elif root._key > node._key:
                root._node_on_left = self. _insert_as_node(root._node_on_left, node)
            else:
                root._node_on_right = self. _insert_as_node(root._node_on_right, node)

        return root


    def _remove(self, node:NodeType, key:int) -> tuple: #return Nodetype, bool
        # do not describe anything directly.
        # your code goes here, not a public method.
        
        #insert key,value to _nodes
        if key in self._nodes:
            del self._nodes[key]

        if node is None:
            return node, False

        result = False
        if key == node._key:
            result = True
            if node._node_on_left and node._node_on_right:
                top, bottom = node, node._node_on_right
                while bottom._node_on_left is not None:
                    top, bottom = bottom, bottom._node_on_left
                bottom._node_on_left = node._node_on_left
                if top != node:
                    top._node_on_left = bottom._node_on_right
                    bottom._node_on_right = node._node_on_right
                node = bottom
            elif node._node_on_left or node._node_on_right:
                node = node._node_on_left or node._node_on_right
            else:
                node = None

        elif key < node._key:
            node._node_on_left, result = self._remove(node._node_on_left, key)
        else:
            node._node_on_right, result = self._remove(node._node_on_right, key)
        return node, result


    def _find(self, root:NodeType, key:int) -> NodeType:
        # do not describe anything directly.
        # your code goes here, not a public method.
        
        if root is None or root._key == key:
            return root
        elif key < root._key:
            return self._find(root._node_on_left, key)
        else:
            return self._find(root._node_on_right, key)

    def insert(self, data, key:int=0) -> bool:
        # your code goes here in a public method.

        # if value is not None and node is not None:
        #     raise ArgumentException('value and node not to be given at the same time.')

        #How to make difference between node and value clearly?
        if isinstance(data, Node):
            self._root = self._insert_as_node(self._root,data)
            return True
        else:
            self._root = self._insert_as_value(self._root,key,data)
            return True

    def remove(self, key:int) -> bool:
        # your code goes here in a public method.
        self._root, result = self._remove(self._root,key)

        return result

    def find(self, key:int) -> NodeType:
        # your code goes here in a public method.
        
        return self._find(self._root,key)

    @staticmethod
    def dumps(cls, object_:BinaryTreeType) -> str:
        # this method should be treated as static method.

        return json.dumps(object_.nodes)

    @staticmethod
    def loads(cls, str_:str) -> BinaryTreeType:
        # this method should be treated as static method.

        nodes = json.loads(str_)

        tree = BinaryTree(nodes['key'])

        del nodes['key']

        for nodetuple in nodes.items():
            node = Node(int(nodetuple[0]))
            node._value = nodetuple[1]
            tree.insert(node)
        
        return tree

    @staticmethod
    def dump(cls, object_:BinaryTreeType) -> str:
        # this method should be treated as static method
        # and also described with static method "dumps"
        
        treestr = 'data/BinaryTree_{0}.json'.format(object_._key)

        with open(treestr, "w") as fp:

            fp.write(object_.dumps(cls,object_))

    @staticmethod
    def load(cls, fp:IO[str]) -> BinaryTreeType:
        # this method should be treated as static method
        # and also described with static method "loads"

        return BinaryTree.loads(BinaryTree,fp.read())

if __name__ == "__main__":
    nodes = [Node(1),Node(2),Node(3),Node(4),Node(5),Node(6),Node(7),Node(8)]
    nodes[0]._value = "1st"
    tree = BinaryTree(1)

    print("insert ======")
    for node in nodes:
        print(tree.insert(node))
        print(tree._root)
        print(tree.nodes)
    
    print("find ======")
    print(tree.find(1))
    print(tree.nodes)
    print(tree.find(2))
    print(tree.nodes)
    print(tree.find(3))
    print(tree.nodes)

    print("remove ======")
    print(tree.remove(1))
    print(tree.nodes)
    print(tree.find(1))
    print(tree.nodes)
    print(tree.remove(1))
    print(tree.nodes)
    print(tree.remove(4))
    print(tree.nodes)
    print(tree.remove(3))
    print(tree.nodes)
    
    dumpstest = BinaryTree.dumps(BinaryTree,tree)
    print(dumpstest)
    BinaryTree.dump(BinaryTree,tree)

    tree2 = BinaryTree.loads(BinaryTree,dumpstest)

    print(tree2.nodes)

    fp = open("data/BinaryTree_1.json",'r')

    tree3 = BinaryTree.load(BinaryTree,fp)

    fp.close()

    print(tree3.nodes)

