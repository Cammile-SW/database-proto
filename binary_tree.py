
'''
21.3.5  add : KeyGenerator(temp)
        mod : insert, insert_as_value, insert_as_node, nodes, dumps, dump, Node(__str__,__repr__)

        update need:
                    loads 함수에서 insert로 tree 만드는것을 node를 만들어서 tree로 만드는걸로 바꾸기

                    insert_as_.. -> node 반환 이유 : 들어간 친구 다시 반환 , 잘 들어갔나 확인차
                                 -> recursive 함수를 밖으로 빼서 정의함으로써 아규먼트를 직관적으로 변경, 타입체크 등 확장성 증대
                    argument type hint 잘 적기

                    
'''

'''
[module structure hierarchy]

unidentified class which will be discussed in future

    +- binary tree 01
        +- node instance 01
        +- node instance 02
        > node instances goes on ...

    +- binary tree 02
        +- node instance 01
        +- node instance 02
        > node instances goes on ...
    
    > binary tree instances goes on ...

'''
import json

from typing import TypeVar
from typing import IO

# variables for strong-type.

from strong_type import SelfObject
from strong_type import is_satisfied_strongly

strong_node_init = (
    (1, 'key', [int]), 
    (3, 'node_on_left', [None, SelfObject]), 
    (4, 'node_on_right', [None, SelfObject]),
    )

strong_btree_init = (
    (1, 'key', [int]),
    )

# variables for type-hint.

NodeType = TypeVar('NodeType')
BinaryTreeType = TypeVar('BinaryTreeType')

# module description.

class ArgumentException(Exception):
    '''argument exception class'''

    def __init__(self, message:str):
        super().__init__(message)

class Node(object):
    '''node class'''

    # key for identify node instance
    _key = None

    # value which is contained node instance
    _value = None

    # left node instance on this instance (reference) 
    _node_on_left = None

    # right node instance on this instance (reference)
    _node_on_right = None

    @is_satisfied_strongly(strong_node_init)
    def __init__(
            self, 
            key:int, 
            value:object=None,
            node_on_left:NodeType=None,
            node_on_right:NodeType=None
            ):

        # key should be given by 
        # relative-upper management class instance,
        # not by itself.
        # e.g. this node key is generated by its tree.

        self._key = key
        self._value = value
        self._node_on_left = node_on_left
        self._node_on_right = node_on_right

    def __str__(self):
        cls_ = self.__class__.__name__
        key = self._key
        val = self._value

        left = None if self._node_on_left is None \
            else self._node_on_left._key 

        right = None if self._node_on_right is None \
            else self._node_on_right._key

        return f'{cls_}<{key}:{val}, l:{left}, r:{right}>'


    def __repr__(self):
        cls_ = self.__class__.__name__
        key = self._key
        val = self._value

        left = None if self._node_on_left is None \
            else self._node_on_left._key 
        
        right = None if self._node_on_right is None \
            else self._node_on_right._key

        return f'{cls_}<{key}:{val}, l:{left}, r:{right}>'

    @property
    def key(self) -> int:
        return self._key

    @property
    def value(self) -> object:
        return self._value

    @property
    def node_on_left(self) -> NodeType:
        return self._node_on_left

    @property
    def node_on_right(self) -> NodeType:
        return self._node_on_right

class KeyGenerator(int):
    # BinaryTree key generator

    _treekey = None

    _key = None

    def __init__(self,treekey:int):
        self._treekey = treekey
        self._key = 0

    @property
    def treekey(self) -> int:
        return self._treekey

    @property
    def key(self) -> int:
        return self._key

    def autokey(self) -> int:
        self._key += 1
        return self._key


class BinaryTree(object):
    '''node class'''
    
    # key for identify binary tree instance
    _key = None

    # root node instance
    _root = None

    # KeyGenerator instance
    _keygenerator = None

    @is_satisfied_strongly(strong_btree_init)
    def __init__(self, key:int):
        # key should be given by 
        # a relative-upper management class instance,
        # not by itself.

        self._key = key
        self._keygenerator = KeyGenerator(key)

    @property
    def key(self) -> int:
        return self._key

    @property
    def nodes(self) -> NodeType:
        def treesearch(node:Node):
            if(node is not None):
                yield from treesearch(node.node_on_left)
                yield node
                yield from treesearch(node.node_on_right)
        
        return treesearch(self._root)

    def _insert_as_value(self, parent:Node, key:int, value:object) -> Node:
        # do not describe anything directly.
        # your code goes here, not a public method.

        # generate node -> insert
        node = Node(key)
        node._value = value

        if parent is None:
            #inserting first node
            parent = node

        else:
            if parent._key == node._key:
                pass

            elif parent._key > node._key:
                parent._node_on_left = self._insert_as_value(parent._node_on_left, key, value)
                
            else:
                parent._node_on_right = self._insert_as_value(parent._node_on_right, key, value)

        return parent
    
    def _insert_as_node(self, parent:Node, node:NodeType) -> Node:
        # do not describe anything directly.
        # your code goes here, not a public method.

        if parent is None:
            #inserting first node
            parent = node
        else:
            if parent._key == node._key:
                #raise Exception
                pass
            elif parent._key > node._key:
                parent._node_on_left = self. _insert_as_node(parent._node_on_left, node)
            else:
                parent._node_on_right = self. _insert_as_node(parent._node_on_right, node)

        return parent

    def _remove(self, node:NodeType, key:int) -> tuple: #return Nodetype, bool
        # do not describe anything directly.
        # your code goes here, not a public method.
        
        if node is None:
            return node, False

        result = False
        if key == node._key:
            result = True
            if node._node_on_left and node._node_on_right:
                top, bottom = node, node._node_on_right
                while bottom._node_on_left is not None:
                    top, bottom = bottom, bottom._node_on_left
                bottom._node_on_left = node._node_on_left
                if top != node:
                    top._node_on_left = bottom._node_on_right
                    bottom._node_on_right = node._node_on_right
                node = bottom
            elif node._node_on_left or node._node_on_right:
                node = node._node_on_left or node._node_on_right
            else:
                node = None

        elif key < node._key:
            node._node_on_left, result = self._remove(node._node_on_left, key)
        else:
            node._node_on_right, result = self._remove(node._node_on_right, key)
        return node, result

    def _find(self, parent:NodeType, key:int) -> Node:
        # do not describe anything directly.
        # your code goes here, not a public method.
        
        if parent is None or parent._key == key:
            return parent
        elif key < parent._key:
            return self._find(parent._node_on_left, key)
        else:
            return self._find(parent._node_on_right, key)

    def insert(self, data) -> bool:
        # your code goes here in a public method.

        # if value is not None and node is not None:
        #     raise ArgumentException('value and node not to be given at the same time.')

        #How to make difference between node and value clearly?
        if isinstance(data, Node):
            self._root = self._insert_as_node(self._root,data)
            return True

        else:
            key = self._keygenerator.autokey()
            self._root = self._insert_as_value(self._root, key, value)
            return True

    def remove(self, key:int) -> bool:
        # your code goes here in a public method.
        self._root, result = self._remove(self._root,key)

        return result

    def find(self, key:int) -> Node:
        # your code goes here in a public method.
        
        return self._find(self._root,key)

    @staticmethod
    def dumps(cls, object_:BinaryTreeType) -> str:
        # this method should be treated as static method.
        nodesdic = {}
        nodesdic.update({'key':object_.key})

        for node in object_.nodes:
            nodesdic.update({node.key:node.value})

        return json.dumps(nodesdic)

    @staticmethod
    def loads(cls, str_:str) -> BinaryTreeType:
        # this method should be treated as static method.

        nodes = json.loads(str_)

        tree = BinaryTree(nodes['key'])

        del nodes['key']

        for nodetuple in nodes.items():
            node = Node(int(nodetuple[0]))
            node._value = nodetuple[1]
            tree.insert(node)
        
        return tree

    @staticmethod
    def dump(cls, object_:BinaryTreeType, fp) -> str:
        # this method should be treated as static method
        # and also described with static method "dumps"
        
        fp.write(object_.dumps(cls,object_))

    @staticmethod
    def load(cls, fp:IO[str]) -> BinaryTreeType:
        # this method should be treated as static method
        # and also described with static method "loads"

        return BinaryTree.loads(BinaryTree,fp.read())

if __name__ == "__main__":
    # nodes = [Node(1),Node(2),Node(3),Node(4),Node(5),Node(6),Node(7),Node(8)]
    # nodes[0]._value = "1st"
    values = ['this','is','value','insert','test']
    tree = BinaryTree(1)

    for value in values:
        tree.insert(value)
    
    treestr = BinaryTree.dumps(BinaryTree,tree)
    
    treeadd = 'data/BinaryTree_{0}.json'.format(tree._key)

    with open(treeadd, "w") as fp:

        BinaryTree.dump(BinaryTree,tree,fp)

    with open(treeadd, "r") as fp:
        tree2 = BinaryTree.load(BinaryTree,fp)

    for i in tree2.nodes:
        print(i)

    tree3 = BinaryTree.loads(BinaryTree,treestr)

    for i in tree3.nodes:
        print(i)


    
        

